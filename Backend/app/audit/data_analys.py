import requests
import json
import subprocess
import dotenv
import os

dotenv.load_dotenv()

# Словарь с описаниями уязвимостей Slither (переведенные и адаптированные)
# Ключ - название детектора Slither, Значение - понятное описание для отчета
VULNERABILITY_DESCRIPTIONS = {
    # --- Критические и Высокие ---
    "abiencoderv2-array": "Ошибка компилятора (Solidity 0.4.7-0.5.9): Некорректная кодировка массивов при использовании ABI Encoder v2, может привести к повреждению данных.",
    "arbitrary-send-erc20": "ERC20 Токены отправляются на адрес, который может контролировать пользователь, без должной проверки отправителя (`msg.sender`). Это может позволить обойти проверки доступа.",
    "arbitrary-send-erc20-permit": "ERC20 Токены отправляются с использованием функции `permit()` на адрес, контролируемый пользователем, без проверки реального отправителя (`msg.sender`). Риск обхода авторизации.",
    "arbitrary-send-eth": "Контракт отправляет Ether на адрес, который может контролироваться пользователем, без надлежащих проверок. Это может привести к краже средств.",
    "array-by-reference": "Массив передается в функцию как ссылка на хранилище (`storage ref`), хотя ожидается копия в памяти (`memory`). Неожиданное изменение исходного массива.",
    "controlled-array-length": "Длина массива в хранилище (`storage`) устанавливается значением, которое может контролировать пользователь. Риск перезаписи важных данных или DoS-атаки.",
    "controlled-delegatecall": "Контракт выполняет `delegatecall` или `callcode` на адрес, контролируемый пользователем. Это критическая уязвимость, позволяющая атакующему выполнить произвольный код в контексте контракта.",
    "delegatecall-loop": "`delegatecall` используется внутри цикла в функции, принимающей оплату (`payable`). Потенциальная DoS-атака через исчерпание газа.",
    "encode-packed-collision": "Использование `abi.encodePacked()` с динамическими типами данных может привести к коллизиям хэшей, когда разные входные данные дают одинаковый результат. Может использоваться для обхода проверок.",
    "incorrect-shift": "В ассемблерной вставке (`assembly`) перепутаны аргументы операции битового сдвига (`shl`, `shr`, `sar`). Приводит к неверным расчетам.",
    "locked-ether": "Контракт может принимать Ether (есть `payable` функции), но не имеет механизма для его вывода. Средства будут заблокированы навсегда.",
    "multiple-constructors": "Обнаружено несколько конструкторов (старый стиль до Solidity 0.4.22 и новый `constructor`). Может привести к ошибкам при деплое и инициализации.",
    "name-reused": "Два или более контракта в проекте имеют одинаковое имя. Это приведет к конфликту при компиляции, и в артефактах сохранится только один из них.",
    "protected-vars": "Переменные помечены как 'защищенные' (возможно, комментарием), но не имеют реальной защиты доступа (например, `internal` или `private`). Ложное чувство безопасности.",
    "public-mappings-nested": "До Solidity 0.5 публичные вложенные отображения (`mapping`) возвращали некорректные значения при прямом обращении. Ошибка чтения данных.",
    "reentrancy-eth": "Классическая Reentrancy (повторный вход) через отправку Ether. Атакующий может многократно вызывать функцию контракта до завершения первого вызова, потенциально выводя больше средств, чем положено.",
    "reentrancy-no-eth": "Reentrancy (повторный вход) через вызов внешнего контракта (не связанный с отправкой Ether). Может использоваться для манипулирования состоянием контракта.",
    "reentrancy-benign": "Reentrancy (повторный вход), которая не приводит к краже средств, но позволяет выполнить одну и ту же логику несколько раз (двойной вызов). Может нарушить ожидаемое поведение.",
    "reentrancy-events": "Reentrancy (повторный вход), которая позволяет атакующему изменить порядок или значения генерируемых событий (`event`). Может использоваться для обмана внесетевых систем мониторинга.",
    "reentrancy-unlimited-gas": "Использование `transfer()` или `send()` для отправки Ether небезопасно, так как лимит газа для вызываемого контракта может измениться в будущем. Рекомендуется использовать `call{value: ...}(\"\")`.",
    "return-bomb": "Низкоуровневый вызов (`call`, `delegatecall`, `staticcall`) может привести к исчерпанию всего газа вызывающего контракта, если вызываемый контракт содержит специальный код ('return bomb'). DoS-атака.",
    "rtlo": "Использование специального символа Unicode (U+202E, Right-To-Left Override) в именах функций или переменных для маскировки реальной логики кода. Попытка обфускации.",
    "shadowing-state": "State-переменная в дочернем контракте имеет то же имя, что и переменная в родительском контракте, 'затеняя' ее. Может привести к путанице и ошибкам.",
    "storage-array": "Ошибка компилятора (Solidity 0.4.7-0.5.9): Некорректные значения в массивах знаковых целых чисел (`int[]`) в хранилище (`storage`).",
    "suicidal": "Функция `selfdestruct()` (или `suicide()`) может быть вызвана любым пользователем, что позволяет уничтожить контракт и вывести его баланс на произвольный адрес.",
    "tx-origin": "Авторизация основана на `tx.origin`. Если пользователь вызовет вредоносный контракт, тот сможет выполнить действия от имени пользователя в целевом контракте. Следует использовать `msg.sender`.",
    "unchecked-lowlevel": "Возвращаемое значение низкоуровневого вызова (`call`, `delegatecall`, `staticcall`, `send`) не проверяется. Вызов мог завершиться неудачей, но контракт продолжит выполнение, как будто все прошло успешно.",
    "unchecked-send": "Возвращаемое значение `send()` не проверяется. `send()` может завершиться неудачно (например, из-за лимита газа), но контракт не узнает об этом. Используйте `call`.",
    "unchecked-transfer": "Возвращаемое значение функций `transfer()` или `transferFrom()` стандарта ERC20 не проверяется. Некоторые токены возвращают `false` при ошибке вместо revert, что может привести к потере средств.",
    "uninitialized-state": "State-переменная используется до ее явной инициализации. По умолчанию она равна нулю, что может быть не тем значением, которое ожидается.",
    "uninitialized-storage": "Локальная переменная-указатель на `storage` используется без инициализации. Она будет указывать на первый слот хранилища (слот 0), и запись в нее перезапишет важные данные.",
    "uninitialized-local": "Локальная переменная используется до ее инициализации. Ее значение будет неопределенным (или нулевым), что приведет к ошибкам.",
    "uninitialized-fptr-cst": "Ошибка компилятора (Solidity 0.4.5-0.4.26, 0.5.0-0.5.8): Неожиданное поведение при вызове неинициализированных указателей на функции в конструкторе.",
    "unprotected-upgrade": "В обновляемом контракте (прокси) логический контракт может быть уничтожен (`selfdestruct`), так как функция `initialize()` не защищена от повторного вызова или отсутствует конструктор.",
    "weak-prng": "Генерация случайных чисел основана на предсказуемых значениях (`block.timestamp`, `now`, `blockhash`). Майнеры могут влиять на эти значения, делая 'случайные' числа предсказуемыми.",

    # --- Средние ---
    "constant-function-asm": "Функция объявлена как `constant` (устаревшее) или `pure`/`view`, но содержит ассемблерный код, который потенциально может изменять состояние. Некорректная маркировка функции.",
    "constant-function-state": "Функция объявлена как `constant` (устаревшее) или `pure`/`view`, но изменяет состояние контракта (например, записывает в state-переменную). Некорректная маркировка функции.",
    "divide-before-multiply": "Выполнение целочисленного деления до умножения может привести к потере точности из-за усечения остатка. Например, `(a / b) * c` может дать не тот же результат, что и `(a * c) / b`.",
    "domain-separator-collision": "Сигнатура функции в контракте конфликтует с `DOMAIN_SEPARATOR()` из EIP-2612 (используется в `permit()`). Это может нарушить работу функции `permit` для токенов ERC20.",
    "enum-conversion": "Ошибка компилятора (Solidity < 0.4.5): Преобразование значения в `enum` может привести к выходу за пределы допустимого диапазона без ошибки.",
    "erc20-interface": "Реализация стандарта ERC20 некорректна: функции (например, `transfer`) не возвращают `bool`, как требует стандарт (для Solidity > 0.4.22). Это может вызвать проблемы совместимости.",
    "erc721-interface": "Реализация стандарта ERC721 некорректна: функции не возвращают значения, как требует стандарт. Проблемы совместимости.",
    "incorrect-equality": "Используется строгое равенство (`==`) для проверки условий, которыми легко манипулировать (например, `block.timestamp`). Атакующий может подстроить условия.",
    "incorrect-exp": "Использование побитового XOR (`^`) вместо возведения в степень (`**`). Частая ошибка, приводит к неверным вычислениям.",
    "incorrect-modifier": "Модификатор не содержит `_` (продолжение выполнения функции) или не всегда возвращает управление. Функция, использующая такой модификатор, может не выполниться или вернуть некорректный результат.",
    "incorrect-return": "В ассемблерной вставке (`assembly`) используется `return` там, где следовало бы использовать `stop` или `leave`, что может привести к неожиданному завершению выполнения.",
    "mapping-deletion": "Удаление структуры (`struct`), содержащей отображение (`mapping`), не удаляет само отображение. Данные остаются доступными и могут быть использованы для атаки.",
    "msg-value-loop": "Использование `msg.value` внутри цикла. Если значение `msg.value` велико, цикл может потребовать слишком много газа и привести к DoS-атаке.",
    "out-of-order-retryable": "Некорректная реализация повторяемых транзакций (например, в Arbitrum).",
    "pyth-deprecated-functions": "Используется устаревшая функция оракула Pyth. Необходимо обновить интеграцию.",
    "pyth-unchecked-confidence": "Цена, полученная от оракула Pyth, используется без проверки уровня достоверности (`confidence interval`). Цена может быть неточной.",
    "pyth-unchecked-publishtime": "Цена, полученная от оракула Pyth, используется без проверки времени публикации (`publishTime`). Цена может быть устаревшей.",
    "reused-constructor": "Один и тот же конструктор базового контракта вызывается несколько раз в иерархии наследования с разными аргументами. Может привести к неправильной инициализации.",
    "return-leave": "В ассемблерной вставке (`assembly`) используется `return` в функции, которая должна была бы использовать `leave` для выхода из текущего блока кода.",
    "shadowing-abstract": "Переменная состояния 'затеняет' переменную с тем же именем из абстрактного контракта-родителя.",
    "shadowing-builtin": "Имя локальной переменной, state-переменной, функции, модификатора или события совпадает со встроенным символом Solidity (например, `now`, `require`). Может привести к путанице и ошибкам.",
    "shadowing-local": "Локальная переменная или параметр функции 'затеняет' state-переменную или другую локальную переменную с тем же именем во внешней области видимости.",
    "tautological-compare": "Переменная сравнивается сама с собой (например, `x >= x`). Такое сравнение всегда истинно (для `>=, <=, ==`) или ложно (для `>`, `<`, `!=`) и, скорее всего, является ошибкой.",
    "tautology": "Логическое выражение всегда истинно (тавтология) или всегда ложно (противоречие), независимо от входных данных. Вероятно, ошибка в логике.",
    "uninitialized-fptr-cst": "Ошибка компилятора (Solidity 0.4.5-0.4.26, 0.5.0-0.5.8): Неожиданное поведение при вызове неинициализированных указателей на функции в конструкторе.", # Дубликат, но оставим для полноты
    "unused-return": "Возвращаемое значение внешнего вызова не используется (не сохраняется в переменную и не проверяется). Результат вызова теряется.",
    "write-after-write": "В переменную записывается значение, которое затем перезаписывается без промежуточного чтения. Первая запись бесполезна.",

    # --- Низкие и Информационные ---
    "assembly": "Использование вставок на ассемблере (`assembly`) повышает риск ошибок и усложняет аудит. Рекомендуется избегать без крайней необходимости.",
    "assert-state-change": "Использование `assert()` для проверок, которые могут изменить состояние контракта. `assert()` предназначен для инвариантов и потребляет весь газ при ошибке.",
    "boolean-cst": "Неправильное использование булевых констант, например, `if (myBool == true)` вместо `if (myBool)`.",
    "boolean-equal": "Сравнение булевых переменных с литералами `true` или `false`. Рекомендуется использовать `if (var)` или `if (!var)`.",
    "cache-array-length": "Длина массива из хранилища (`storage`) считывается на каждой итерации цикла. Эффективнее сохранить длину в локальную переменную (`memory`) перед циклом.",
    "calls-loop": "Внешние вызовы внутри цикла. Может привести к DoS-атаке, если количество итераций велико или вызываемый контракт потребляет много газа.",
    "chainlink-feed-registry": "Используется Chainlink Feed Registry. Это информационное сообщение, указывающее на зависимость от конкретной сети (пока только Ethereum Mainnet).",
    "chronicle-unchecked-price": "Цена, полученная от оракула Chronicle, используется без проверки на валидность. Оракул может быть неактивен.",
    "codex": "Информационное сообщение: использовался инструмент Codex для поиска уязвимостей (не является уязвимостью само по себе).",
    "constable-states": "State-переменная инициализируется при объявлении и никогда не изменяется. Ее можно объявить как `constant` для экономии газа.",
    "costly-loop": "Цикл содержит операции, потребляющие много газа (например, запись в `storage`). Может привести к превышению лимита газа.",
    "cyclomatic-complexity": "Функция имеет высокую цикломатическую сложность (слишком много ветвлений). Ее трудно тестировать и понимать. Рекомендуется разбить на более мелкие функции.",
    "dead-code": "Обнаружен неиспользуемый код (функции, переменные), который никогда не вызывается или не читается. Усложняет анализ и должен быть удален.",
    "deprecated-standards": "Используются устаревшие конструкции языка Solidity (`throw`, `sha3()`, `suicide()`, старые модификаторы видимости и т.д.). Рекомендуется использовать современные аналоги.",
    "erc20-indexed": "Параметры событий (`event`) стандарта ERC20 (например, `from`, `to` в `Transfer`) не помечены как `indexed`. Это затрудняет поиск и фильтрацию событий вне сети.",
    "events-access": "Важные изменения контроля доступа (например, смена владельца) происходят без генерации соответствующего события (`event`). Затрудняет мониторинг.",
    "events-maths": "Критические арифметические операции или изменения параметров выполняются без генерации событий (`event`). Затрудняет мониторинг.",
    "external-function": "Функция объявлена как `public`, но вызывается только извне контракта. Можно объявить ее как `external` для небольшой экономии газа.",
    "function-init-state": "State-переменная инициализируется результатом вызова не-`view`/`pure` функции или с использованием неконстантных переменных. Может привести к недетерминированному поведению при деплое.",
    "gelato-unprotected-randomness": "Используется функция `_requestRandomness` Gelato без надлежащей защиты доступа. Может быть вызвана кем угодно.",
    "immutable-states": "State-переменная устанавливается только в конструкторе и больше не изменяется. Ее можно объявить как `immutable` для экономии газа.",
    "incorrect-modifier": "Модификатор не содержит `_` или не возвращает управление. (Дубликат, приоритет у среднего уровня)",
    "incorrect-unary": "Использование унарных операторов, которые могут быть опечатками, например `x =+ 1` вместо `x += 1` или `x = x + 1`.",
    "incorrect-using-for": "Объявление `using A for B` не имеет эффекта, если библиотека `A` не содержит функций, принимающих тип `B` в качестве первого аргумента.",
    "low-level-calls": "Использование низкоуровневых вызовов (`call`, `delegatecall`, `staticcall`). Повышает риск ошибок, так как не проверяется наличие кода у адресата и успех вызова по умолчанию.",
    "missing-inheritance": "Контракт реализует все функции интерфейса или абстрактного контракта, но не наследует его явно (`is InterfaceName`).",
    "missing-zero-check": "Присвоение адреса переменной или параметру без проверки на нулевой адрес (`address(0)`). Может привести к ошибкам или блокировке средств.",
    "naming-convention": "Нарушение общепринятых соглашений об именовании в Solidity (переменные и функции в `camelCase`, контракты и библиотеки в `PascalCase`, константы в `UPPER_CASE_WITH_UNDERSCORES`). Снижает читаемость.",
    "optimism-deprecation": "Используется устаревший метод или предварительно развернутый контракт сети Optimism.",
    "pragma": "Используются разные версии компилятора Solidity (`pragma solidity ...`) в разных файлах проекта. Рекомендуется зафиксировать одну версию.",
    "redundant-statements": "Обнаружены избыточные операторы, которые не влияют на выполнение кода (например, `x;`, где `x` - переменная). Загромождают код.",
    "solc-version": "Используется старая версия компилятора Solidity. Рекомендуется использовать последнюю стабильную версию (или как минимум 0.8.0), не содержащую известных критических ошибок.",
    "too-many-digits": "Числовые литералы содержат много цифр и трудно читаются. Используйте символ подчеркивания `_` как разделитель (например, `1_000_000`) или научную нотацию.",
    "unimplemented-functions": "Контракт наследует интерфейс или абстрактный контракт, но не реализует все его функции. Контракт не скомпилируется.",
    "unused-state": "State-переменная объявлена, но нигде не используется (не читается и не записывается). Следует удалить.",
    "variable-scope": "Переменная используется до ее объявления или в другой области видимости, где она недоступна (ошибка компиляции, но Slither может поймать в некоторых случаях).",
    "var-read-using-this": "Чтение state-переменной через `this.variable` вместо прямого `variable`. Это приводит к дополнительному внешнему вызову (`STATICCALL`) и расходует больше газа.",
    "void-cst": "Вызывается конструктор базового контракта, который не реализован (например, в интерфейсе).",
}
def get_contract_source_code(contract_address, api_key, chain):
    chains = {
        'mainnet': '1',
        'base': '8453',
        'arbitrum': '42161',
    }
    api_url = "https://api.etherscan.io/v2/api"
    params = {
        "chainid": chains[chain],
        "module": "contract",
        "action": "getsourcecode",
        "address": contract_address,
        "apikey": api_key
    }

    try:
        response = requests.get(api_url, params=params)
        response.raise_for_status()
        data = response.json()

        if data["status"] == "1" and data["message"] == "OK":
            source_code_info = data["result"][0]
            source_code = source_code_info.get("SourceCode")
            if source_code and source_code.startswith('{'):
                if source_code.startswith('{{') and source_code.endswith('}}'):
                    source_code_json = json.loads(source_code[1:-1])
                    print('1')
                    return source_code_json["sources"]
                else:
                    print('2')
                    return json.loads(source_code)

            elif source_code:
                 print('3')
                 return source_code
            else:
                 print(f"Исходный код для контракта {contract_address} не найден или не верифицирован.")
                 return None
        else:
            print(f"Ошибка API Etherscan: {data.get('message', 'Неизвестная ошибка')} (Result: {data.get('result')})")
            return None

    except requests.exceptions.RequestException as e:
        print(f"Ошибка сети при запросе к Etherscan API: {e}")
        return None
    except json.JSONDecodeError:
         print("Ошибка декодирования JSON из поля SourceCode.")
         return source_code_info.get("SourceCode")
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
        return None
    
    
def compile_solidity_files(address, chain):
    
    etherscan_api_key = os.getenv("ETHERSCAN_API_KEY")
    
    chains = {
        'mainnet': 'mainnet',
        'base': 'base',
        'arbitrum': 'arbi',
    }
    
    print("analysing", address)
    command = [
        "slither",
        f"{chains[chain]}:{address}",
        "--etherscan-apikey",
        etherscan_api_key,
        "--json",
        "-"
    ]

    result = subprocess.run(
        command,
        capture_output=True,
        text=True,
        encoding='utf-8'
    )
    
    contract_source_code = get_contract_source_code(address, etherscan_api_key, chain)
    json_data = json.loads(result.stdout)
    extracted_data = extract_vulnerability_lines_from_file(json_data)
    findings = []
    for item in extracted_data:
        vulnerability_lines = ''
        if type(contract_source_code) == str:
            for line_num in item['function_lines']:
                if 0 < line_num <= len(contract_source_code.split('\n')):
                    line = contract_source_code.split('\n')[line_num - 1].strip()
                    vulnerability_lines += f"  {line}\n"
        else:
            try:
                for line_num in item['function_lines']:
                    if 0 < line_num <= len(contract_source_code[item['filename_short']]['content'].split('\n')):
                        line = contract_source_code[item['filename_short']]['content'].split('\n')[line_num - 1].strip()
                        vulnerability_lines += f"  {line}\n"
            except:
                print(item['function_lines'])
        findings.append({
            "vulnerability": item['vulnerability'],
            "description": None if item['vulnerability'] not in VULNERABILITY_DESCRIPTIONS else VULNERABILITY_DESCRIPTIONS[item['vulnerability']],
            "function_name": item['function_name'],
            "confidence": item['confidence'],
            "function_lines": vulnerability_lines,
            "impact": item['impact']
        })
    return findings

def extract_vulnerability_lines_from_file(data):
    results_list = []
    
    for detector in data["results"]["detectors"]:
        check_name = detector.get("check")
        function_lines = None
        function_name = None

        if "elements" in detector:
            for element in detector["elements"]:
                function_name = element.get("name")
                if "source_mapping" in element and "lines" in element["source_mapping"]:
                    function_lines = element["source_mapping"]["lines"]
                    filename_short = element["source_mapping"]["filename_short"]
                    break

        if check_name and function_lines:
            results_list.append({
                "vulnerability": check_name,
                "function_name": function_name,
                "function_lines": function_lines,
                "confidence": detector.get("confidence"),
                "impact": detector.get("impact"),
                "filename_short": filename_short
            })

    return results_list

etherscan_api_key = os.getenv("ETHERSCAN_API_KEY")

# print(get_contract_source_code('0x1D3e0b0806281517617B20dB1Ab235885c3D7da1', etherscan_api_key, 'base'))
print(compile_solidity_files('0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', 'mainnet'))
